---
title: Polarisation analysis
author: Laura Ospina-Rozo
editor_options: 
  chunk_output_type: console
---

In this script we study the Polarisation trait corrected by phylogeny.

# Setting up

## Libraries

Libraries sourced from an additional script.

```{r message = FALSE, warning=FALSE}
source(here::here("Scripts/MacroEcol_1_Libraries.R"))
```

## Data sets

Import polarisation data.

```{r}
# elytra
PolBySpp <- read.csv(here::here("Data/FromCode/PolarzElytraBySpp.csv"))[-1]
PolByInd <- read.csv(here::here("Data/FromCode/PolarzElytraByInd.csv"))[-1]

# elytra and pronotum
BeetlePol <- read.csv(here::here("Data/FromCode/PolarzElytraPronot.csv"))[-1]
```

All statistical analysis were done at the species level (polarisation data by species). Plots are produced with the polarisation data by individual.

And we imported the phylogeny from a .nwk file which contains 2000 phylogenetic trees. This allows us to test our hypothesis in multiple trees and not only on the MCC tree. This way, we account for any uncertainty in unresolved tips of our phylogeny.

```{r}
# Phylogeny
trees <- ape::read.tree(here::here("Data/XMAS_mat2b_bst2ef_set23nn2_pinct.nwk"))

# Set subset limits
trees_subset_min<-1000
trees_subset_max<-2000

MCCtree <- 
  ape::read.nexus(here::here("Data/xmas_mat2b_bst2ef_set23nn2_pinct_med.tre"))
```

To explore the correlations between ecological variables and polarisation

```{r}
# PC Values
PCValuesF <- read.csv(here::here("Data/FromCode/PCsbySpp.csv"))[-1] %>% 
  dplyr::rename("PC1" = PC1_1, "PC2" = PC2_1)

# merge with polarisation
PolPCs <- merge(PCValuesF, PolBySpp)

# adapt to merge with phylogeny
PolPCs2 <- as.data.frame(PolPCs) # create new data frame
rownames(PolPCs2) <- PolPCs2[, 1] # make species the row names
PolPCsRows <- PolPCs2[, 2:length(PolPCs2)] # eliminate spp name (redundant)
```

To explore correlations with reflectivity

```{r}
# Reflectivity data consolidated by species
ReflBySpp <- read.csv(here::here("Data/FromCode/ConsolidatedReflectivitySpp.csv"))[-1] %>% 
  dplyr::arrange(phylogeny_name)

# Merge with polarisation
PolRefl <- merge(ReflBySpp, PolBySpp)

# adapt to merge with phylogeny
PolRefl2 <- as.data.frame(PolRefl) # create new data frame
rownames(PolRefl2) <- PolRefl2[, 1] # make species the row names
PolReflRows <- PolRefl2[, 2:length(PolRefl2)] # eliminate spp name (redundant)
```

To explore correlations with absorptivity

```{r}
AbsBySpp <- read.csv(here::here("Data/FromCode/ConsolidatedAbsorptivitySpp.csv"))[-1] %>%
  dplyr::arrange(phylogeny_name)

# merge with polarisation
PolAbs <- merge(AbsBySpp, PolBySpp)

# adapt to merge with phylogeny
PolAbs2 <- as.data.frame(PolAbs) # create new data frame
rownames(PolAbs2) <- PolAbs2[, 1] # make species the row names
PolAbsRows <- PolAbs2[, 2:length(PolAbs2)] # eliminate spp name (redundant)
```

We prune the species in the tree that are not present in the dataset

```{r}

# Prune extra spp in the tree, not contain in the test sample
PolAbs.species.MCC <- as.data.frame(unique(PolAbs2$phylogeny_name))

# Convert to "row names" (required for following steps)
row.names(PolAbs.species.MCC) <- PolAbs.species.MCC[, 1] 

# Make sure the names in data set and tree match
PolAbs.temp.MCC <- name.check(MCCtree, PolAbs.species.MCC)

# This step is necessary because the tips are different.
MCCtreeAbs <- drop.tip(MCCtree, PolAbs.temp.MCC$tree_not_data)

# Test if the species are the same
identical(
  length(name.check(MCCtreeAbs, PolAbs2$phylogeny_name)$tree_not_data),
  length(PolAbs2$phylogeny_name)
)
```

# Body part

It is possible that different selective pressures apply to the elytra than to other parts of the beetle body. There are various species that seem to have stronger structural coloration in the pronotum. They may have lost the polarization in their elytra.

**Are there differences in the polarisation between the elytra and pronotum of the same individual?**

<p style="color: #04C799">

**Statistics**

</p>

Conduct a paired t-test to compare the mean of the difference to 0. A negative difference would mean that in general the pronotum is more polarized than the elytra.

```{r}
# Paired t test
t.test(BeetlePol$Difference)
```

The mean difference in polarisation between the two body parts is not significantly different than 0.

<p style="color: #04C799">

**Plots**

</p>

```{r}
hist(BeetlePol$Difference,
    breaks = 20,
    xlab = "Difference in polarization (Elytra-Pronot)",
    ylab = "Frequency"
)
```

These beetles with higher polarisation in their elytra are:

```{r}
ElytraMoreP <-
    BeetlePol %>%
    dplyr::filter(Difference > 0.1)

ElytraMoreP$ind
```

These beetles with higher polarisation in their pronotum are:

```{r}
PronotumMoreP <-
    BeetlePol %>%
    dplyr::filter(Difference < -0.1)

PronotumMoreP$ind
```

# Ecological variables

<p style="color: #04C799">

**Question**

</p>

**Is polarization correlated to the extracted climate variables?**

<p style="color: #04C799">

**Statistics**

</p>

## Pagel's lambda

```{r}

pagelPDPol <- PolPCsRows$Pol # Define which trait we want to test
names(pagelPDPol) <- rownames(PolPCsRows) # Row names = tree tips
phylosig(MCCtree, pagelPDPol, method = "lambda", test = TRUE, nsim = 999)
# nsim = 999 means testing with 999 randomisations
```

Phylogenetic signal is high.

## PGLS in the MCC

Create the data frame of comparative data

```{r}

# extract sizes
SizesDf <- PolRefl %>% 
              dplyr::select("phylogeny_name", "size")
# merge size into ecological variables dataset
PolPCsWithSizes <- merge(SizesDf, PolPCs)

comp_data2 <- comparative.data(
    phy = MCCtree,
    data = PolPCsWithSizes, # aggregated data without the spp in the row names
    names.col = "phylogeny_name", # contains the column phylogeny name
    vcv = TRUE,
    na.omit = FALSE, warn.dropped = TRUE
)
```

Establish the model

```{r message= FALSE, warnings=FALSE}

pglsPDPol <- pgls(Pol ~ PC1 + PC2 + size + PC1 * size + PC2 * size,
    data = comp_data2, param.CI = 0.95, lambda = "ML"
)

summary(pglsPDPol)
```

<p style="color: #04C799">

**Conclusion**

</p>

**Polarization does not directly correlate with these ecological variables**

## PGLS in multiple trees

Function

Note that the function has to be modified for the predictors and data frame that we are using

```{r warning=FALSE, message=FALSE}
source(here::here("Scripts/7_multiple_pgls_function_B.R")) # script B is for Polarization as a response
```

Model

```{r}
MuPGLSPol2 <- Polarization ~ PC1 + PC2 + size + PC1 * size + PC2 * size
```

Dataset

```{r message=FALSE}
# Add the phylogeny name again because in this function it is needed:
PDPol2 <-
    PolPCsWithSizes %>%
    dplyr::select(phylogeny_name, Pol, size, PC1, PC2) %>% 
    dplyr::rename("Polarization" = Pol)

PDPol2 <- as.data.frame(PDPol2)
rownames(PDPol2) <- PDPol2[, 1]
```

Apply

```{r message=FALSE, warning=FALSE}
runsPol2 <- lapply(trees[trees_subset_min:trees_subset_max],
                   pgls_runB, model = MuPGLSPol2, dataset = PDPol2)

dfPol2 <- ldply(runsPol2, data.frame)
```

Get results

```{r}
HPDinterval(as.mcmc(dfPol2))
```

# Optical properties

## Reflectivity

### VIS

<p style="color: #04C799">

**Question**

</p>

**Can polarisation predict visible reflectivity?**

<p style="color: #04C799">

**Correlation**

</p>

```{r}
cor.test(PolRefl$VIS, PolRefl$Pol) # by spp
```

<p style="color: #04C799">

**Linear model**

</p>

```{r}
ModL1 <- lm(PolRefl$VIS ~ PolRefl$Pol) # by spp
summary(ModL1)
```

<p style="color: #04C799">

**PGLS**

</p>

Create the data frame of comparative data

```{r}

comp_data <- comparative.data(
  phy = MCCtree,
  data = PolRefl, # aggregated data without the spp in the row names
  names.col = "phylogeny_name", # contains the column phylogeny name
  vcv = TRUE,
  na.omit = FALSE, warn.dropped = TRUE
)
```

Establish the model

```{r message= FALSE, warnings=FALSE}
pglsPDVIS <- pgls(VIS ~ Pol,
  data = comp_data, param.CI = 0.95, lambda = "ML"
)

summary(pglsPDVIS)
```

<p style="color: #04C799">

**PGLS multiple trees**

</p>

Function

Note that the function has to be modified for the predictors and data frame that we are using

```{r warning=FALSE, message=FALSE}
source(here::here("Scripts/6_multiple_pgls_function_A.R")) # script A is for Polarization as a response
```

Model

```{r}
MuPGLSPol3 <- Response ~ Pol
```

Dataset

```{r message=FALSE}

PolRefl3 <-
    PolReflRows %>% # phylogeny names in rows
    dplyr::select(Pol, VIS) %>% 
    dplyr::rename("Response" = VIS)

PolRefl3 <- as.data.frame(PolRefl3)
```

Apply

```{r message=FALSE, warning=FALSE}
runsPol3 <- lapply(trees[trees_subset_min:trees_subset_max],
                   pgls_runA, model = MuPGLSPol3, dataset = PolRefl3)

dfPol3 <- ldply(runsPol3, data.frame)
```

Get results

```{r}
HPDinterval(as.mcmc(dfPol3))
```

[ **Conclusion** ]{style="color: #04C799"} <br/>

**There's no correlation between visible reflectivity and polarisation at the species level.**

<br> <br> <br>

### NIR

<p style="color: #04C799">

**Question**

</p>

**Is polarisation correlated with NIR reflectivity?**

<p style="color: #04C799">

**Correlation**

</p>

Species level:

```{r}
cor.test(PolRefl$NIR, PolRefl$Pol) # by spp
```

<p style="color: #04C799">

**Linear model**

</p>

```{r}
ModL2 <- lm(PolRefl$NIR ~ PolRefl$Pol + PolRefl$VIS) # by spp
summary(ModL2)
```

<p style="color: #04C799">

**PGLS**

</p>

The data frame of comparative data is the same as for visible light

```{r message= FALSE, warnings=FALSE}
pglsPDNIR <- pgls(NIR ~ Pol + VIS,
  data = comp_data, param.CI = 0.95, lambda = "ML"
)

summary(pglsPDNIR)
```

<p style="color: #04C799">

**PGLS multiple trees**

</p>

Function

Note that the function has to be modified for the predictors and data frame that we are using

```{r warning=FALSE, message=FALSE}
source(here::here("Scripts/13_multiple_pgls_function_H.R")) # script A is for Polarization as a response
```

Model

```{r}
MuPGLSPol4 <- Response ~ Pol + VIS
```

Dataset

```{r message=FALSE}

PolRefl4 <-
    PolReflRows %>% # phylogeny names in rows
    dplyr::select(Pol, VIS, NIR) %>% 
    dplyr::rename("Response" = NIR)

PolRefl4 <- as.data.frame(PolRefl4)
```

Apply

```{r message=FALSE, warning=FALSE}
runsPol4 <- lapply(trees[trees_subset_min:trees_subset_max],
                   pgls_runH, model = MuPGLSPol4, dataset = PolRefl4)

dfPol4 <- ldply(runsPol4, data.frame)
```

Get results

```{r}
HPDinterval(as.mcmc(dfPol4))
```

### FRS

<p style="color: #04C799">

**Question**

</p>

**Is polarisation correlated with the NIR residuals corrected by phylogeny?**

<p style="color: #04C799">

**Correlation**

</p>

Species level:

```{r}
cor.test(PolRefl$FRS, PolRefl$Pol) # by spp
```

<p style="color: #04C799">

**Linear model**

</p>

```{r}
ModL3 <- lm(PolRefl$FRS ~ PolRefl$Pol) # by spp
summary(ModL3)
```

<p style="color: #04C799">

**PGLS**

</p>

The data frame of comparative data is the same as for visible light

```{r message= FALSE, warnings=FALSE}
pglsPDFRS <- pgls(FRS ~ Pol,
  data = comp_data, param.CI = 0.95, lambda = "ML"
)

summary(pglsPDFRS)
```

<p style="color: #04C799">

**PGLS multiple trees**

</p>

Dataset

```{r message=FALSE}

PolRefl5 <-
    PolReflRows %>% # phylogeny names in rows
    dplyr::select(Pol, FRS) %>% 
    dplyr::rename("Response" = FRS)

PolRefl5 <- as.data.frame(PolRefl5)
```

Apply

```{r message=FALSE, warning=FALSE}
runsPol5 <- lapply(trees[trees_subset_min:trees_subset_max],
                   pgls_runA, model = MuPGLSPol3, dataset = PolRefl5)

dfPol5 <- ldply(runsPol5, data.frame)
```

Get results

```{r}
HPDinterval(as.mcmc(dfPol5))
```

## Absorptivity

### VIS

<p style="color: #04C799">

**Question**

</p>

**Can polarisation predict visible absorptivity?**

<p style="color: #04C799">

**Correlation**

</p>

```{r}
cor.test(PolAbs$VIS, PolAbs$Pol) # by spp
```

<p style="color: #04C799">

**Linear model**

</p>

```{r}
ModL1Abs <- lm(PolAbs$VIS ~ PolAbs$Pol) # by spp
summary(ModL1Abs)
```

<p style="color: #04C799">

**PGLS**

</p>

Create the data frame of comparative data

```{r}

CompDataAbs <- comparative.data(
  phy = MCCtreeAbs,
  data = PolAbs, # aggregated data without the spp in the row names
  names.col = "phylogeny_name", # contains the column phylogeny name
  vcv = TRUE,
  na.omit = FALSE, warn.dropped = TRUE
)
```

Establish the model

```{r message= FALSE, warnings=FALSE}
pglsPDVISAbs <- pgls(VIS ~ Pol,
  data = CompDataAbs, param.CI = 0.95, lambda = "ML"
)

summary(pglsPDVISAbs)
```

<p style="color: #04C799">

**PGLS multiple trees**

</p>

Dataset

```{r message=FALSE}

PolAbs3 <-
    PolAbsRows %>% # phylogeny names in rows
    dplyr::select(Pol, VIS) %>% 
    dplyr::rename("Response" = VIS)

PolAbs3 <- as.data.frame(PolAbs3)
```

Apply

```{r message=FALSE, warning=FALSE}
runsPol6 <- lapply(trees[trees_subset_min:trees_subset_max],
                   pgls_runA, model = MuPGLSPol3, dataset = PolAbs3)

dfPol6 <- ldply(runsPol6, data.frame)
```

Get results

```{r}
HPDinterval(as.mcmc(dfPol6))
```

[ **Conclusion** ]{style="color: #04C799"} <br/>

**There's no correlation between visible absorptivity and polarisation at the species level.**

<br> <br> <br>

### NIR

<p style="color: #04C799">

**Question**

</p>

**Is polarisation correlated with NIR absorptivity?**

<p style="color: #04C799">

**Correlation**

</p>

Species level:

```{r}
cor.test(PolAbs$NIR, PolAbs$Pol) # by spp
```

<p style="color: #04C799">

**Linear model**

</p>

```{r}
ModL2Abs <- lm(PolAbs$NIR ~ PolAbs$Pol + PolAbs$VIS) # by spp
summary(ModL2Abs)
```

<p style="color: #04C799">

**PGLS**

</p>

The data frame of comparative data is the same as for visible light

```{r message= FALSE, warnings=FALSE}
pglsPDNIRAbs <- pgls(NIR ~ Pol + VIS,
  data = CompDataAbs, param.CI = 0.95, lambda = "ML"
)

summary(pglsPDNIRAbs)
```

<p style="color: #04C799">

**PGLS multiple trees**

</p>

Dataset

```{r message=FALSE}

PolAbs4 <-
    PolAbsRows %>% # phylogeny names in rows
    dplyr::select(Pol, VIS, NIR) %>% 
    dplyr::rename("Response" = NIR)

PolAbs4 <- as.data.frame(PolAbs4)
```

Apply

```{r message=FALSE, warning=FALSE}
runsPol7 <- lapply(trees[trees_subset_min:trees_subset_max],
                   pgls_runH, model = MuPGLSPol4, dataset = PolAbs4)

dfPol7 <- ldply(runsPol7, data.frame)
```

Get results

```{r}
HPDinterval(as.mcmc(dfPol7))
```

### FRS

<p style="color: #04C799">

**Question**

</p>

**Is polarisation correlated with the NIR residuals corrected by phylogeny?**

<p style="color: #04C799">

**Correlation**

</p>

Species level:

```{r}
cor.test(PolAbs$FRS, PolAbs$Pol) # by spp
```

<p style="color: #04C799">

**Linear model**

</p>

```{r}
ModL3Abs <- lm(PolAbs$FRS ~ PolAbs$Pol) # by spp
summary(ModL3Abs)
```

<p style="color: #04C799">

**PGLS**

</p>

The data frame of comparative data is the same as for visible light

```{r message= FALSE, warnings=FALSE}
pglsPDFRSAbs <- pgls(FRS ~ Pol,
  data = CompDataAbs, param.CI = 0.95, lambda = "ML"
)

summary(pglsPDFRSAbs)
```

<p style="color: #04C799">

**PGLS multiple trees**

</p>

Dataset

```{r message=FALSE}

PolAbs5 <-
    PolAbsRows %>% # phylogeny names in rows
    dplyr::select(Pol, FRS) %>% 
    dplyr::rename("Response" = FRS)

PolAbs5 <- as.data.frame(PolAbs5)
```

Apply

```{r message=FALSE, warning=FALSE}
runsPol8 <- lapply(trees[trees_subset_min:trees_subset_max],
                   pgls_runA, model = MuPGLSPol3, dataset = PolAbs5)

dfPol8 <- ldply(runsPol8, data.frame)
```

Get results

```{r}
HPDinterval(as.mcmc(dfPol8))
```

# Mechanisms

We tested the correlations between optical properties, i.e. reflectivity and absorptivity, and polarisation in different subsets of species since these correlations may depend on the underlaying mechanisms.

## Subsets

We will compare three scenarios: 1) all species included 2) excluding the species with a white underlay since they clearlyu have a different mechanism that doe snot involve polarisation. 3) some species may be combining additional structures or disorder with chiral structures. This would change the correlations between polarisation and reflectivity, thus in this scenario we also exclude these cases (clustering appart from the other species).

Subset no underlay:

```{r}
# reflectivity
NoUnderlayRefl <-
  PolRefl %>%
  dplyr::filter(phylogeny_name != "Paraschizognathus_ocularis" &
    phylogeny_name != "Paraschizognathus_prasinus" &
    phylogeny_name != "Paraschizognathus_olivaceous" &
    phylogeny_name != "Anoplognathus_prasinus" &
    phylogeny_name != "Xylonichus_sp")

# absorptivity
NoUnderlayAbs <-
  PolAbs %>%
  dplyr::filter(phylogeny_name != "Paraschizognathus_ocularis" &
    phylogeny_name != "Paraschizognathus_prasinus" &
    phylogeny_name != "Paraschizognathus_olivaceous" &
    phylogeny_name != "Anoplognathus_prasinus" &
    phylogeny_name != "Xylonichus_sp")
```

Subset no special cases:

```{r}
# reflectivity
NoSpecialCasesRefl <-
  PolRefl %>%
  dplyr::filter(phylogeny_name != "Paraschizognathus_ocularis" &
    phylogeny_name != "Paraschizognathus_prasinus" &
    phylogeny_name != "Paraschizognathus_olivaceous" &
    phylogeny_name != "Anoplognathus_prasinus" &
    phylogeny_name != "Xylonichus_sp" &
    phylogeny_name != "Epichrysus_lamprimoides" &
    phylogeny_name != "Anoplostethus_laetus" &
    phylogeny_name != "Anoplostethus_opalinus" &
    phylogeny_name != "Anoplostethus_roseus" &
    phylogeny_name != "Anoplognathus_parvulus" &
    phylogeny_name != "Anoplognathus_aureus")

# absorptivity
NoSpecialCasesAbs <-
  PolAbs %>%
  dplyr::filter(phylogeny_name != "Paraschizognathus_ocularis" &
    phylogeny_name != "Paraschizognathus_prasinus" &
    phylogeny_name != "Paraschizognathus_olivaceous" &
    phylogeny_name != "Anoplognathus_prasinus" &
    phylogeny_name != "Xylonichus_sp" &
    phylogeny_name != "Epichrysus_lamprimoides" &
    phylogeny_name != "Anoplostethus_laetus" &
    phylogeny_name != "Anoplostethus_opalinus" &
    phylogeny_name != "Anoplostethus_roseus" &
    phylogeny_name != "Anoplognathus_parvulus" &
    phylogeny_name != "Anoplognathus_aureus")
```

Subset no chiral composites:

```{r}
# reflectivity
NoCCRefl <-
  PolRefl %>%
  dplyr::filter(phylogeny_name != "Epichrysus_lamprimoides" &
    phylogeny_name != "Anoplostethus_laetus" &
    phylogeny_name != "Anoplostethus_opalinus" &
    phylogeny_name != "Anoplostethus_roseus" &
    phylogeny_name != "Anoplognathus_parvulus" &
    phylogeny_name != "Anoplognathus_aureus")

# absorptivity
NoCCAbs <-
  PolAbs %>%
  dplyr::filter(phylogeny_name != "Epichrysus_lamprimoides" &
    phylogeny_name != "Anoplostethus_laetus" &
    phylogeny_name != "Anoplostethus_opalinus" &
    phylogeny_name != "Anoplostethus_roseus" &
    phylogeny_name != "Anoplognathus_parvulus" &
    phylogeny_name != "Anoplognathus_aureus")
```

## Reflectivity

### VIS

<p style="color: #04C799">

**All species**

</p>

```{r}
cor.test(PolRefl$VIS, PolRefl$Pol) # by spp
```

<p style="color: #04C799">

**No underlay**

</p>

```{r}
cor.test(NoUnderlayRefl$VIS, NoUnderlayRefl$Pol) # by spp
```

<p style="color: #04C799">

**No special cases**

</p>

```{r}
cor.test(NoSpecialCasesRefl$VIS, NoSpecialCasesRefl$Pol) # by spp
```

<p style="color: #04C799">

**No chiral composites**

</p>

```{r}
cor.test(NoCCRefl$VIS, NoCCRefl$Pol) # by spp
```

### NIR

<p style="color: #04C799">

**All species**

</p>

```{r}
cor.test(PolRefl$NIR, PolRefl$Pol) # by spp
```

<p style="color: #04C799">

**No underlay**

</p>

```{r}
cor.test(NoUnderlayRefl$NIR, NoUnderlayRefl$Pol) # by spp
```

<p style="color: #04C799">

**No special cases**

</p>

```{r}
cor.test(NoSpecialCasesRefl$NIR, NoSpecialCasesRefl$Pol) # by spp
```

<p style="color: #04C799">

**No chiral composites**

</p>

```{r}
cor.test(NoCCRefl$NIR, NoCCRefl$Pol) # by spp
```

### FRS

<p style="color: #04C799">

**All species**

</p>

```{r}
cor.test(PolRefl$FRS, PolRefl$Pol) # by spp
```

<p style="color: #04C799">

**No underlay**

</p>

```{r}
cor.test(NoUnderlayRefl$FRS, NoUnderlayRefl$Pol) # by spp
```

<p style="color: #04C799">

**No special cases**

</p>

```{r}
cor.test(NoSpecialCasesRefl$FRS, NoSpecialCasesRefl$Pol) # by spp
```

<p style="color: #04C799">

**No chiral composites**

</p>

```{r}
cor.test(NoCCRefl$FRS, NoCCRefl$Pol) # by spp
```

## Absorptivity

### VIS

<p style="color: #04C799">

**All species**

</p>

```{r}
cor.test(PolAbs$VIS, PolAbs$Pol) # by spp
```

<p style="color: #04C799">

**No underlay**

</p>

```{r}
cor.test(NoUnderlayAbs$VIS, NoUnderlayAbs$Pol) # by spp
```

<p style="color: #04C799">

**No special cases**

</p>

```{r}
cor.test(NoSpecialCasesAbs$VIS, NoSpecialCasesAbs$Pol) # by spp
```

<p style="color: #04C799">

**No chiral composites**

</p>

```{r}
cor.test(NoCCAbs$VIS, NoCCAbs$Pol) # by spp
```

### NIR

<p style="color: #04C799">

**All species**

</p>

```{r}
cor.test(PolAbs$NIR, PolAbs$Pol) # by spp
```

<p style="color: #04C799">

**No underlay**

</p>

```{r}
cor.test(NoUnderlayAbs$NIR, NoUnderlayAbs$Pol) # by spp
```

<p style="color: #04C799">

**No special cases**

</p>

```{r}
cor.test(NoSpecialCasesAbs$NIR, NoSpecialCasesAbs$Pol) # by spp
```

<p style="color: #04C799">

**No chiral composites**

</p>

```{r}
cor.test(NoCCAbs$NIR, NoCCAbs$Pol) # by spp
```

### FRS

<p style="color: #04C799">

**All species**

</p>

```{r}
cor.test(PolAbs$FRS, PolAbs$Pol) # by spp
```

<p style="color: #04C799">

**No underlay**

</p>

```{r}
cor.test(NoUnderlayAbs$FRS, NoUnderlayAbs$Pol) # by spp
```

<p style="color: #04C799">

**No special cases**

</p>

```{r}
cor.test(NoSpecialCasesAbs$FRS, NoSpecialCasesAbs$Pol) # by spp
```

<p style="color: #04C799">

**No chiral composites**

</p>

```{r}
cor.test(NoCCAbs$FRS, NoCCAbs$Pol) # by spp
```

# Plots

```{r}
ReflByInd <- read.csv(here::here("Data/FromCode/ConsolidatedReflectivityInd.csv"))[-1]

AbsByInd0 <- read.csv(here::here("Data/FromCode/ConsolidatedAbsorptivityInd.csv"))[-1]
AbsByInd0$A_Res <- residuals ( lm (AbsByInd0$A_NIR~AbsByInd0$A_VIS))

# Mean and sd per species Absorptivity
AbsByInd <-
AbsByInd0 %>%
  dplyr::mutate("spp" = substr(ind, 1, 4)) %>%
  dplyr::select(spp, A_VIS, A_NIR, A_Res) %>% 
  dplyr::group_by(spp) %>% 
  dplyr::summarise(
    meanVISA = mean(A_VIS),
    meanNIRA = mean(A_NIR),
    meanResA = mean(A_Res),
    sdVISA = sd(A_VIS),
    sdNIRA = sd(A_NIR),
    sdResA = sd(A_Res),
      )
AbsByInd <- as.data.frame(AbsByInd)


# Mean and sd per species Reflectivity
ToPlotPolRefl <-
  merge(ReflByInd[,c(1,3,4,5)], PolByInd, by = "ind") %>%
  dplyr::select(-phylogeny_name) %>%
  dplyr::group_by(spp) %>%
  dplyr::summarise(
    meanVIS = mean(R_VIS),
    meanNIR = mean(R_NIR),
    meanRes = mean(Res),
    meanPol = mean(Polarization),
    sdVIS = sd(R_VIS),
    sdNIR = sd(R_NIR),
    sdRes = sd(Res),
    sdPol = sd(Polarization)
  )

ToPlotPolRefl <- as.data.frame(ToPlotPolRefl)
rownames(ToPlotPolRefl) <- ToPlotPolRefl$spp

ToPlotPolAbs <- merge(
  ToPlotPolRefl[,c("spp", "meanPol", "sdPol")], AbsByInd)
rownames(ToPlotPolAbs) <- ToPlotPolAbs$spp

```

Subset for plotting

```{r}
UnderlayRefl <- ToPlotPolRefl %>%
  dplyr::filter(spp == "xyls" |
                spp == "xyle" | 
                spp == "pczo" |
                spp == "pczp" |
                spp == "pczv" |
                spp == "prsi")
UnderlayAbs <- ToPlotPolAbs %>%
  dplyr::filter(spp == "xyls" |
                spp == "xyle" | 
                spp == "pczo" |
                spp == "pczp" |
                spp == "pczv" |
                spp == "prsi")

NoUnderlayRefl <- ToPlotPolRefl %>%
  dplyr::filter(spp != "xyls" |
                spp != "xyle" | 
                spp != "pczo" |
                spp != "pczp" |
                spp != "pczv" |
                spp != "prsi")
NoUnderlayAbs <- ToPlotPolAbs %>%
  dplyr::filter(spp != "xyls" |
                spp != "xyle" | 
                spp != "pczo" |
                spp != "pczp" |
                spp != "pczv" |
                spp != "prsi")
```

Predictions from PGLS for the NIR reflectivity and absorptivity

```{r}
## set values for predictors: 
PolDeg <- seq(range(ToPlotPolRefl$meanPol)[1],
             range(ToPlotPolRefl$meanPol)[2],0.01) # A range of Pol values

new1<-data.frame("Pol" = PolDeg) # data frame

RefDeg<-predict(pglsPDFRS, newdata = new1, 
              type = "response") # Expected reflectivity
trend1<-data.frame(PolDeg,RefDeg) # Pol values and expected reflectivity joint

AbsDeg<-predict(pglsPDFRSAbs, newdata = new1, 
              type = "response") # Expected absorptivity
trend2<-data.frame(PolDeg,AbsDeg) # Pol values and expected reflectivity joint

```

Predictions from PGLS for the NIR absorptivity

```{r}
## set values for predictors: 
PolDeg <- seq(range(ToPlotPolRefl$meanPol)[1],
             range(ToPlotPolRefl$meanPol)[2],0.01) # A range of Pol values

new1<-data.frame("Pol" = PolDeg) # data frame

RefDeg<-predict(pglsPDFRS, newdata = new1, 
              type = "response") # Expected reflectivity

trend1<-data.frame(PolDeg,RefDeg) # Pol values and expected reflectivity joint

```



```{r}

NudgeXVal = 0.04
NudgeYVal = 0.9

PVRPlot <- ggplot(data = ToPlotPolRefl, aes(x = meanPol, y = meanVIS),
             size = 2.2, alpha = 0.6) +
  geom_text(
    label=rownames(ToPlotPolRefl), 
    nudge_x = NudgeXVal, nudge_y = NudgeYVal, 
    col="gray", size=3
  ) +
  # error bars
  geom_errorbar(aes(
                ymin = meanVIS - sdVIS,
                ymax = meanVIS + sdVIS),
  col = "#cecec2"
  ) +
  geom_errorbarh(aes(
    xmin = meanPol - sdPol,
    xmax = meanPol + sdPol
  ),
  col = "#cecec2"
  ) +
  geom_point(data = NoUnderlayRefl, size = 2.2, pch = 21, fill = "#648fff", color = "black", alpha = 0.7) +
  geom_point(data = UnderlayRefl, size = 2.4, pch = 22, fill = "#F7E949", color = "black", alpha = 0.7) +
  theme_minimal() +
  theme(legend.position = "none") + 
  xlab("Degree of Polarisation (L - R)/(L + R)")+
  ylab("Visible reflectivity (%)") +
  ylim(0, 50)

PNRPlot <- ggplot(data = ToPlotPolRefl, aes(x = meanPol, y = meanRes),
             size = 2.2, alpha = 0.6) +
  geom_text(
    label=rownames(ToPlotPolRefl), 
    nudge_x = NudgeXVal, nudge_y = NudgeYVal, 
    col="gray", size=3
  ) +
  # error bars
  geom_errorbar(aes(
                ymin = meanRes - sdRes,
                ymax = meanRes + sdRes),
  col = "#cecec2"
  ) +
  geom_errorbarh(aes(
    xmin = meanPol - sdPol,
    xmax = meanPol + sdPol
  ),
  col = "#cecec2"
  ) +
  geom_point(data = NoUnderlayRefl, size = 2.2, pch = 21, fill = "#648fff", color = "black", alpha = 0.7) +
  geom_point(data = UnderlayRefl, size = 2.4, pch = 22, fill = "#F7E949", color = "black", alpha = 0.7) +
  geom_line(data=trend1, aes(x= PolDeg, y= RefDeg), color = "black") +
  theme_minimal() +
  theme(legend.position = "none") + 
  xlab("Degree of Polarisation (L - R)/(L + R)")+
  ylab("NIR (Res) reflectivity (%)") 


PVAPlot <- ggplot(data = ToPlotPolAbs, aes(x = meanPol, y = meanVISA),
             size = 2.2, alpha = 0.6) +
  geom_text(
    label=rownames(ToPlotPolAbs), 
    nudge_x = NudgeXVal, nudge_y = NudgeYVal, 
    col="gray", size=3
  ) +
  # error bars
  geom_errorbar(aes(
                ymin = meanVISA - sdVISA,
                ymax = meanVISA + sdVISA),
  col = "#cecec2"
  ) +
  geom_errorbarh(aes(
    xmin = meanPol - sdPol,
    xmax = meanPol + sdPol
  ),
  col = "#cecec2"
  ) +
  geom_point(data = NoUnderlayAbs, size = 2.2, pch = 21, fill = "#648fff", color = "black", alpha = 0.7) +
  geom_point(data = UnderlayAbs, size = 2.4, pch = 22, fill = "#F7E949", color = "black", alpha = 0.7) +
  theme_minimal() +
  theme(legend.position = "none") + 
  xlab("Degree of Polarisation (L - R)/(L + R)")+
  ylab("Visible absorptivity (%)") +
  ylim(0, 100)

PNAPlot <- ggplot(data = ToPlotPolAbs, aes(x = meanPol, y = meanResA),
             size = 2.2, alpha = 0.6) +
  geom_text(
    label=rownames(ToPlotPolAbs), 
    nudge_x = NudgeXVal, nudge_y = NudgeYVal, 
    col="gray", size=3
  ) +
  # error bars
  geom_errorbar(aes(
                ymin = meanResA - sdResA,
                ymax = meanResA + sdResA),
  col = "#cecec2"
  ) +
  geom_errorbarh(aes(
    xmin = meanPol - sdPol,
    xmax = meanPol + sdPol
  ),
  col = "#cecec2"
  ) +
  geom_point(data = NoUnderlayAbs, size = 2.2, pch = 21, fill = "#648fff", color = "black", alpha = 0.7) +
  geom_point(data = UnderlayAbs, size = 2.4, pch = 22, fill = "#F7E949", color = "black", alpha = 0.7) +
  geom_line(data=trend2, aes(x= PolDeg, y= AbsDeg), color = "black") +
  theme_minimal() +
  theme(legend.position = "none") + 
  xlab("Degree of Polarisation (L - R)/(L + R)")+
  ylab("NIR (Res) absorptivity (%)") 
  

grid.arrange(PVRPlot, PNRPlot, PVAPlot, PNAPlot, nrow = 2)
```