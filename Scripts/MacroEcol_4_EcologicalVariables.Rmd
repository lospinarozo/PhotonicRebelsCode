---
title: "Summarising ecological variables into principal components"
#author: "Laura Ospina-Rozo"
#date: "25/04/2022"
editor_options: 
  chunk_output_type: console
---

<br>
<br>

# Setting up 

Libraries sourced from an additional script

```{r, warning=FALSE, message=FALSE}
source(here::here("Scripts/MacroEcol_1_Libraries.R"))
```

Ecological data was obtained from ALA and AWAP data bases through additional scripts (available in the scripts folder of this same project) 

```{r eval=FALSE}
# Data sourced from additional scripts:

# ALA Data
source(here::here("Scripts/1_ALA_variables.R"))
# AWAP Data
source(here::here("Scripts/4_AWAPDailyQueries_2022.R"))
```

We extracted the climate variables correspondent to the activity period of each species (see additional scripts for more details)

```{r message=FALSE}

vegeta <- read_csv(here::here("Data/6_VegetationVariables.csv"))
climat <- read_csv(here::here("Data/7_ClimateVariables.csv"))
locat <- read_csv(here::here("Data/5_Locations.csv"))
```

The climate data we extracted contained many additional variables, but we decided to use only the most informative ones

```{r}

climat <-
  climat %>%
  filter(species != "xyle3" &
    species != "oliv3") %>% # removed. vegetation data not available
  arrange(species) %>%
  dplyr::select(c(1, 5:8, 11:19)) %>%
  dplyr::rename(
    over35 = avg_temp_over_35, # days over 35deg averaged through 10 years
    MaxT = avg_max_temp, # daily -> mean in one month -> mean over 10 y
    MinT = avg_min_temp, # daily -> mean in one month -> mean over 10 y
    Solar = avg_sol, # daily radiation -> mean in month -> mean over 10 y
    Vapour = avg_vpr, # vapor pressure -> mean in month -> mean over 10 y
    Clouds = cloud_cover, # cloud cover per year
    Rain = avg_rr
  ) # rainfall per day -> mean in one month -> mean over 10 years

names(climat)
# Suffix Coll = value for the parameter in the collection month.
# No suffix = average value for this variable across the activity period

vegeta <-
  vegeta %>%
  filter(spp != "vrdi1" &
    spp != "rose05") %>% # removed. climate data not available
  arrange(spp) %>%
  dplyr::select(c(1, 11:18)) # Keep only the vegetation variables

names(vegeta) <- (c(
  "beetle", "NPP", "BareSoil", "LeafArea",
  "FPAR", "Aridity", "C3Macro", "C3Meso", "C4Mega"
)) # rename

EcoVar <-
  data.frame(vegeta, climat) %>%
  dplyr::select(-species) %>%
  dplyr::select(c(1, 6:16)) %>% # Keep only variables for the period of activity
  mutate(AridityN = Aridity * -1) %>% # Because arid = closer to 0
  dplyr::select(-Aridity)
```

Some beetles were removed from the analysis because their position on the phylogeny is uncertain. 

```{r}

EcoVar <-
  EcoVar %>%
  mutate(spp = substr(beetle, 1, 4)) %>%
  filter(
    spp != "ambl" & # Amblyterus cicatricosus
      spp != "psqz" & # Pseudoschizongnatus schoenfeldti
      spp != "saul" & # Saulostomus villosus
      spp != "sqzb" & # Schizognathus burmeisteri
      spp != "sqzc" & # Schizognathus compressicornis
      spp != "sqzm" # Schizognathus mesosternalis
  ) %>% # These species were removed. No phylogenetic info
  dplyr::select(-spp)
```

```{r}
# Group location data by species
LocatAgg <- locat %>% 
  dplyr::mutate(Spp1 = substr(Spp, 1, 4)) %>% 
  dplyr::select(Spp1, Latitude, Longitude) %>% 
  dplyr::group_by(Spp1) %>% 
  dplyr::summarise(
    meanLat = mean(Latitude),
    meanLon = mean(Longitude),
    minLat = min(Latitude),
    maxLat = max(Latitude),
    minLon = min(Longitude),
    maxLon = max(Longitude)
  )

# Subset with only species with white underlay
LocatAggWU <- LocatAgg %>% 
  dplyr::filter(
    Spp1 %in% c("xyls", "prsi", "xyle", "pczo", "pczp", "pczv")
  )

# Subset with only species that cluster
LocatAggC <- LocatAgg %>% 
  dplyr::filter(
    Spp1 %in% c("aurs", "pvul", "rose", "lats", "opal", "ecry")
  )

```

Finally we obtained the data frame `EcoVar` which contains all the relevant ecological variables for the relevant species.  

But before starting the analysis, we studied the correlations between the variables.

<br>
<br>

# Correlations 

We obtained the $R^2$ and correspondent p values for all combinations between the ecological variables.

```{r}

EVarP <- EcoVar[, c(2:length(EcoVar))] # remove the categorical variables

EVarMatP <- Hmisc::rcorr(as.matrix(EVarP))
EVarR2P <- round(EVarMatP$r, 2) # R2 values
EvarCpP <- round(EVarMatP$P, 5) # p  values
```

The following are the results for all variables including Vegetation and climate for activity period:

```{r}

EVarR2P %>%
  kbl() %>%
  kable_paper("hover", full_width = F)

EvarCpP %>%
  kbl() %>%
  kable_paper("hover", full_width = F)
```


Afterwards we removed the variables with correlations of R > 0.8

```{r}

EcolVar <-
  EcoVar %>%
  dplyr::select(-C3Macro, -C4Mega, -C3Meso, -MinT)

EVar <- EcolVar[, c(2:length(EcolVar))] # remove the categorical variables

EVarMat <- Hmisc::rcorr(as.matrix(EVar))
EVarR2 <- round(EVarMat$r, 2) # R2 values
EvarCp <- round(EVarMat$P, 5) # p  values
```

Finally, we considered only these variables:

```{r}

EVarR2 %>%
  kbl() %>%
  kable_paper("hover", full_width = F)

EvarCp %>%
  kbl() %>%
  kable_paper("hover", full_width = F)
```

<br>
<br>

# PCA
<br>

<span style="color: #04C799"> **Testing correlations** </span>  <br/>

Running a PCA is only possible if variables can be correlated:

```{r}
cord <- cor(EVar) # default: pearsons correlation coeficient
N <- dim(EVar)[1] # number of observations
cortest.bartlett(cord, n = N) # Are the variables correlated? Yes p < 0.05
```

Yes, they can be summarised in the new variables called components

<span style="color: #04C799"> **Extract components** </span>  <br/>

Here we extracted the eigen values, components and loadings matrix

```{r}


eigVal <- eigen(cord) # Extract eigen values
vectorev <- eigVal$vectors # vector with the eigen values
compv <- prcomp(EVar, retx = TRUE, center = TRUE, scale. = TRUE) # components
load <- compv$rotation # Loadings matrix
```

<span style="color: #04C799"> **Scree Plot** </span>  <br/>

Represents the eigen values associated to each component. We used only the ones with eigen value > 1.

```{r}

{
  plot(c(1:length(eigVal$values)), eigVal$values,
    type = "b", cex = 1.4,
    ylab = "Eigen Values", xlab = "Principal components",
    pch = 21, bg = "#648fff"
  )
  abline(h = 1, col = "#ff2c85", lwd = 2, lty = 2)
}
```

<span style="color: #04C799"> **Variance Explained** </span>  <br/>

The following table shows the proportion of variance explained by each component.

```{r}

summary(compv)
```

PC1 and PC2 are able to explain 82% of all the variance in ecological habitats for our samples.

<br>

<span style="color: #04C799"> **Loadings Matrix** </span>  <br/>

The colours in the following figure represent the correlations of each variable is to each PC

```{r}

par(mar = c(4, 8, 4, 4))

plot(load[, 1:2],
  cex = 0.8, breaks = c(-1, -0.5, -0.4, -0.3, 0.3, 0.4, 0.5, 1),
  las = 2, ylab = " ", xlab = " ",
  digits = 2,
  col = c(
    "#ff2c85", "#ff85ac",
    "#ffc4d5", "#F7F7F7",
    "#d3d8ff", "#a2b2ff",
    "#648fff"
  ),
  main = "Loadings matrix "
)
```


Lower PC1 = higher humidity (vapour, rain and clouds) lower aridity.</br>

Lower PC2 = higher solar radiation, higher max temp, more days above 35 and more aridity

<br>
<br>

# Plot

```{r}
# brewer.pal(n = 7, name = "Accent")

# Extract PC axes for plotting
PCAvalues <- data.frame(
  Species = EcolVar$beetle,
  compv$x
)

# Extract loadings of the variables
PCAloadings <- data.frame(Variables = rownames(compv$rotation), compv$rotation)

# PC1 vs PC2
ggplot(PCAvalues, aes(x = PC1, y = PC2)) +
  geom_point(fill = "#648fff", col = "black", pch = 21, size = 2, alpha = 0.4) +
  theme_bw() +
  geom_text(
    data = subset(PCAvalues, PC1 > 2 | PC1 < -2.5 | PC2 < -2.5),
    alpha = .3, size = 1, aes(label = Species), col = "black"
  ) +
  annotate("text",
    size = 3,
    x = (PCAloadings$PC1 * 11.5),
    y = (PCAloadings$PC2 * 11.5),
    label = (PCAloadings$Variables)
  ) +
  geom_segment(
    data = PCAloadings[c(1, 2, 3), ],
    aes(
      x = 0, y = 0,
      xend = (PC1 * 11), yend = (PC2 * 11)
    ),
    arrow = arrow(
      length = unit(1 / 2, "picas")
    ),
    color = "#ff2c85"
  ) +
  geom_segment(
    data = PCAloadings[c(4, 5, 6, 7), ],
    aes(
      x = 0, y = 0,
      xend = (PC1 * 11), yend = (PC2 * 11)
    ),
    arrow = arrow(
      length = unit(1 / 2, "picas")
    ),
    color = "#ffb000"
  ) +
  geom_hline(yintercept = 0, linetype = "dashed", colour = "gray") +
  geom_vline(xintercept = 0, linetype = "dashed", colour = "gray") +
  ylim(-10, 5) +
  xlim(-7, 5)
```

<br>
<br>

# New data frames
<br>

<span style="color: #04C799"> **PC values by species** </span>  <br/>

We obtained a data frame with the PC values that summarise the ecological variables considered in our analysis.

```{r}
PC_Values <- PCAvalues[, 1:3]
```

We need one PC value per species. 

```{r}

# Import species names
SppNames <- read.csv(here::here("Data/9_CodesAndSpecies.csv"))

SppNames <-
  SppNames %>%
  mutate(spp = substr(Ind, 1, 4)) %>%
  filter(
    spp != "ambl" & # Amblyterus cicatricosus
      spp != "psqz" & # Pseudoschizongnatus schoenfeldti
      spp != "saul" & # Saulostomus villosus
      spp != "sqzb" & # Schizognathus burmeisteri
      spp != "sqzc" & # Schizognathus compressicornis
      spp != "sqzm" # Schizognathus mesosternalis
  ) %>% # These species were removed. No phylogenetic info
  dplyr::select(-spp) %>%
  arrange(Ind)


# Add specie snames to the PC values data frame
PC_Values$phylogeny_name <- SppNames$phylogeny_name

# Find the mean per species:
FinalPCs <-
  PC_Values %>%
  dplyr::select(-Species) %>%
  dplyr::group_by(phylogeny_name) %>% # group
  dplyr::summarise(across(everything(), list(mean))) # mean

# Print results

write.csv(FinalPCs, here::here("Data/FromCode/PCsbySpp.csv"))
```



<span style="color: #04C799"> **Reflectivity by individual** </span>  <br/>

```{r}

Cons1oo <- read.csv(here::here("Data/FromCode/ConsolidatedReflectivityInd.csv"))[-1]

PC_Values2 <- PC_Values
colnames(PC_Values2) <- c("ind", "PC1", "PC2", "phylogeny_name")
Cons1 <- merge(Cons1oo, PC_Values2, by = "ind") %>% 
  dplyr::rename("phylogeny_name" = phylogeny_name.x) %>% 
  dplyr::select(-phylogeny_name.y)

write.csv(Cons1, here::here("Data/FromCode/ConsReflEcolInd.csv"))
```


<span style="color: #04C799"> **Absorptivity by individual** </span>  <br/>

```{r}

Cons2oo <- read.csv(here::here("Data/FromCode/ConsolidatedAbsoptivityInd.csv"))[-1]

Cons2 <-
  PC_Values %>%
  filter(Species %in% (Cons2oo$ind)) %>% # Subset the PCA values
  arrange(Species) %>%
  bind_cols(., Cons2oo) %>% # join with the 'Optical' Data frame
  dplyr::select(ind, everything(), -Species, -phylogeny_name...7) %>%  # rearrange the column order
  dplyr::rename("phylogeny_name" = phylogeny_name...4)

write.csv(Cons2, here::here("Data/FromCode/ConsAbsEcolInd.csv"))
```

<br>
<br>

# Meaning of each PC

<br>
<br>

**Lower PC1** = higher humidity: vapour, rain and clouds, which in turn correlates with more plant coverage.

**Lower PC2** = higher solar radiation and max temp, more days above 35 and more aridity.

<br>

```{r warning=FALSE, message=FALSE}
library(imager)
im <- load.image(here::here("Data/RmdImages/PCarrows.png"))
plot(im, axes = FALSE)
```

# Correlations with Size

Check the distribution of the size at the species level:

```{r}
getmode <- function(v) {
   uniqv <- unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}

SizeSppDf <-
  Cons1 %>% 
  dplyr::select(size, phylogeny_name) %>% 
  dplyr::group_by(phylogeny_name) %>% 
  dplyr::summarise(
    meanSize = mean(size)
  )

hist(SizeSppDf$meanSize)
mean(SizeSppDf$meanSize)
abline(v=mean(SizeSppDf$meanSize))
abline(v=median(SizeSppDf$meanSize))
getmode(SizeSppDf$meanSize)
```

<br>
<br>

Evaluate at the species level: 

```{r}
PCSZ <-
  Cons1 %>%
  dplyr::select(size, phylogeny_name, PC1, PC2) %>%
  dplyr::group_by(phylogeny_name) %>% # group
  dplyr::summarise(
    meanPC1 = mean(PC1),
    meanPC2 = mean(PC2),
    meanSize = mean(size),
    sdPC1 = sd(PC1),
    sdPC2 = sd(PC2),
    sdSize = sd(size)
  )
```

Checking for correlations between PCs and Size at the species level

```{r}

cor.test(PCSZ$meanSize, PCSZ$meanPC1)

cor.test(PCSZ$meanSize, PCSZ$meanPC2)
```

Plot

```{r warning=FALSE, message=FALSE}
szp1 <- ggplot(PCSZ, aes(x = -meanPC1, y = meanSize)) +
  geom_errorbar(aes(
    ymin = meanSize - sdSize,
    ymax = meanSize + sdSize
  ),
  col = "#cecec2"
  ) +
  geom_errorbarh(aes(
    xmin = -meanPC1 - sdPC1,
    xmax = -meanPC1 + sdPC1
  ),
  col = "#cecec2"
  ) +
  geom_point(
    size = 2, pch = 21, fill = "#648fff",
    colour = "black", alpha = 0.9
  ) +
  theme_minimal() +
  theme(legend.position = "none") +
  geom_smooth(
    method = lm, color = "#648fff",
    fill = "#D3D3D3", size = 0.6
  ) +
  xlab("Humidity (-PC1)") +
  ylab("Size (cm)")


szp2 <- ggplot(PCSZ, aes(x = -meanPC2, y = meanSize)) +
  geom_errorbar(aes(
    ymin = meanSize - sdSize,
    ymax = meanSize + sdSize
  ),
  col = "#cecec2"
  ) +
  geom_errorbarh(aes(
    xmin = -meanPC2 - sdPC2,
    xmax = -meanPC2 + sdPC2
  ),
  col = "#cecec2"
  ) +
  geom_point(
    size = 2, pch = 21, fill = "#ffb000",
    colour = "black", alpha = 0.9
  ) +
  theme_minimal() +
  theme(legend.position = "none") +
  # geom_smooth(method=lm, color="#ffb000", fill="#D3D3D3")+ # Not different than 0
  xlab("Temperature (-PC1)") +
  ylab("Size (cm)")


grid.arrange(szp1, szp2, nrow = 1)
```

# Distribution in Australia

```{r}
oz_states <- ozmaps::ozmap_states # load Australian maps
st_crs(oz_states) <- 4326 # transform have to make due to package problem

ggplot(oz_states) +
  geom_sf() +
  coord_sf(x = c(105.5507, 167.9969), y = c(-43.63203, -9.229287)) +
  geom_point(
    data = LocatAgg, # here the coords data has to be the original format, not spatial format
    aes(x = meanLon, y = meanLat), # if want to change size as well, size = PC2
    alpha = 0.5, color = "black", size = 2
  ) +
  geom_errorbarh(data = LocatAgg, aes(
    xmin = minLon,
    xmax = maxLon,
    y = meanLat
  ), alpha = 0.5) +
  geom_errorbar(data = LocatAgg, aes(
    ymin = minLat,
    ymax = maxLat,
    x = meanLon
  ), alpha = 0.5) +
  #scale_colour_viridis_c() +
  #ggtitle("Total Reflectance") +
  theme_minimal() +
  theme(axis.title.x = element_blank(), axis.title.y = element_blank())
```

Special cases (white underlay)

```{r}
ggplot(oz_states) +
  geom_sf() +
  coord_sf(x = c(105.5507, 167.9969), y = c(-43.63203, -9.229287)) +
  geom_point(
    data = LocatAggWU, # here the coords data has to be the original format, not spatial format
    aes(x = meanLon, y = meanLat), # if want to change size as well, size = PC2
    alpha = 0.9, color = "black", size = 2.8,
    fill = "#648FFF", pch = 21
  ) +
  geom_errorbarh(data = LocatAggWU, aes(
    xmin = minLon,
    xmax = maxLon,
    y = meanLat
  ), alpha = 0.5) +
  geom_errorbar(data = LocatAggWU, aes(
    ymin = minLat,
    ymax = maxLat,
    x = meanLon
  ), alpha = 0.5) +
  #scale_colour_viridis_c() +
  #ggtitle("Total Reflectance") +
  theme_minimal() +
  theme(axis.title.x = element_blank(), axis.title.y = element_blank())
```

Special cases (cluster)

```{r}
ggplot(oz_states) +
  geom_sf() +
  coord_sf(x = c(105.5507, 167.9969), y = c(-43.63203, -9.229287)) +
  geom_point(
    data = LocatAggC, # here the coords data has to be the original format, not spatial format
    aes(x = meanLon, y = meanLat), # if want to change size as well, size = PC2
    alpha = 0.9, color = "black", size = 2.8,
    fill = "#648FFF", pch = 21
  ) +
  geom_errorbarh(data = LocatAggC, aes(
    xmin = minLon,
    xmax = maxLon,
    y = meanLat
  ), alpha = 0.5) +
  geom_errorbar(data = LocatAggC, aes(
    ymin = minLat,
    ymax = maxLat,
    x = meanLon
  ), alpha = 0.5) +
  #scale_colour_viridis_c() +
  #ggtitle("Total Reflectance") +
  theme_minimal() +
  theme(axis.title.x = element_blank(), axis.title.y = element_blank())
```



